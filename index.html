<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Метод за търсене в пространство на състоянията</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(120deg, #0f2027, #203a43, #2c5364);
      color: white;
      overflow-x: hidden;
    }

    header {
      position: sticky;
      top: 0;
      background-color: rgba(0,0,0,0.6);
      padding: 15px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }

    header input[type="text"] {
      padding: 8px 12px;
      border-radius: 5px;
      border: none;
      font-size: 16px;
    }

    .hero {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 0 20px;
      animation: float 8s ease-in-out infinite;
    }

    .hero h1 {
      font-size: 3em;
      color: #ffffff;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.6);
      animation: moveText 5s infinite alternate ease-in-out;
    }

    @keyframes moveText {
      0%   { transform: translateY(0); }
      100% { transform: translateY(-20px); }
    }

    @keyframes float {
      0%   { background-position: 0% 50%; }
      50%  { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .content {
      padding: 40px 20px;
      max-width: 900px;
      margin: auto;
      font-size: 1.2em;
      line-height: 1.6;
    }

    .section {
      margin-bottom: 50px;
    }

    h2, h4 {
      color: #ffcc00;
    }
  </style>
</head>
<body>

  <header>
    <div style="font-weight: bold;"></div>
    <input type="text" placeholder="Търси състояния...">
  </header>

  <section class="hero">
    <h1>Метод за търсене в пространство на състоянията</h1>
  </section>

  <!-- Увод -->
  <section id="Увод" class="content section">
    <h2>Увод</h2>
    <p>В изкуствения интелект често се налага да се намира решение чрез преминаване през различни състояния. Точно с това се занимават методите за търсене в пространство на състоянията – чрез поредица от действия се стига от начална ситуация до търсен резултат. Тези подходи се използват в доста области – от игри и логически пъзели до роботи и автономни системи.</p>
  </section>

  <!-- Историческо развитие -->
  <section id="Историческо развитие" class="content section">
    <h2>Историческо развитие на методите за търсене</h2>
    <p>Търсенето като идея не е нова – още през 50-те и 60-те години на миналия век се появяват първите алгоритми. Сред тях са добре познатите днес Minimax (за игри с двама играчи като шах) и класическите BFS (в ширина) и DFS (в дълбочина). През 70-те се въвеждат и евристични методи – като Best-First и особено популярният A*, който комбинира бързина с ефективност.
        С течение на времето и с развитието на компютърните възможности, се появяват нови варианти, които са по-балансирани откъм използвана памет и качество – например IDA* и MA*. В днешно време търсенето вече се комбинира и с техники от машинното обучение, като например MCTS (Monte Carlo Tree Search), който се използва в сложни игри като Go.
        </p>
  </section>

  <!--. Ранни компютърни програми -->
  <section id="Ранни компютърни програми " class="content section">
    <h4>Ранни компютърни програми</h4>
    <p>Един от пионерите е General Problem Solver (GPS), разработен от Нюъл и Саймън, който използва търсене, за да решава разнообразни задачи. Това полага основата за по-късните подходи в когнитивната наука и ИИ.
        </p>
  </section>

 <!--. Хибридни техники -->
 <section id="Хибридни техники" class="content section">
    <h4>Хибридни техники</h4>
    <p>През 80-те и 90-те започва съчетаването на алгоритми за търсене 
        с логика и експертни системи. Пример са логическите търсения в среди като Prolog. </p>
  </section>



  <!-- Какво представлява пространството на състоянията -->
  <section id="Какво представлява пространството на състоянията" class="content section">
    <h2>Какво представлява пространството на състоянията</h2>
    <p>Това е множеството от всички възможни конфигурации, през които може да премине една система. Основните елементи тук са:0
        началното състояние, позволените действия (оператори), целта, както и стратегията за търсене. В зависимост от задачата, пространството може да изглежда като дърво (при игри и пъзели) или като граф, където е възможно да се върнеш към вече срещано състояние. В такива случаи са нужни допълнителни механизми за избягване на повторения.
        </p>
  </section>

 <!-- Графове и дървета -->
 <section id="Графове и дървета" class="content section">
    <h4>Графове и дървета</h4>
    <p>Обикновено, възлите в тези структури представляват състоянията, 
        а действията са свързващите ръбове. При дървовидните представяния всяко ново състояние 
        е уникално, докато при графите – може да има кръгове и повтарящи се състояния.
        </p>
  </section>

 <!--Ключови характеристики -->
 <section id="Ключови характеристики" class="content section">
    <h4>Ключови характеристики</h4>
    <p>Някои важни фактори, които влияят при избора на подход, са:
        размерът на пространството, колко действия са възможни от всяко състояние (клонящ фактор), и колко стъпки водят до решението (дълбочина).
        
        </p>
  </section>

   <!--Основни методи за търсене -->
 <section id="Основни методи за търсене" class="content section">
    <h2>Основни методи за търсене</h2>
    <p>Най-общо алгоритмите се делят на няколко вида
        Търсене в ширина (BFS) – разглежда всички възможности на едно ниво, преди да слезе по-надълбоко.
        Търсене в дълбочина (DFS) – върви по една възможност докрай, преди да се върне и пробва друга.
        Ограничено по дълбочина – като DFS, но със зададена максимална дълбочина.
        Итеративно задълбочаване – съчетава горните два, като повтаря DFS с нарастваща граница.
        </p>
  </section>


   <!--Сравнение между основните методи -->
   <section id="Сравнение между основните методи" class="content section">
    <h2> Сравнение между основните методи</h2>
    <p>Метод	Оптимален	Пълен	Време / Памет</p>
    <p>BFS	       Да	     Да	    Много (експоненциално)</p> 
    <p>DFS	       Не	     Не	    Малко (линейно)</p>
    <p>IDDFS	   Да	     Да	    Време: високо / Памет: ниско</p>
    <p>A*	       Да	     Да	    Зависи от евристиката</p> 
        <p>BFS гарантира най-кратък път, но изисква много памет. DFS е по-икономичен, но не гарантира добро решение. A* се смята за най-балансиран, ако евристиката му е добре избрана.</p>
        
  </section>




  <!-- Информирано vs. Неинформирано търсене -->
  <section id="Информирано vs. Неинформирано търсене" class="content section">
    <h2>Информирано vs. Неинформирано търсене</h2>
    <p>Неинформираните алгоритми не използват никакви допълнителни знания за разстоянието до целта – това са BFS, DFS и производни. Информираните търсения (евристични) включват Greedy Search и A*, които разчитат на някаква оценка колко сме близо до целта.</p>
  </section>

<!-- Евристични функции -->
<section id="Евристични функции" class="content section">
    <h4>Евристични функции</h4>
    <p>Евристиката връща число, което показва колко сме далеч от решението. Например, при 8-плочковия пъзел:
        Грешни плочки – брой на плочките, които не са на мястото си.
        Манхатън разстояние – сумата от разстоянията по редове и колони до правилната позиция.
        Добра евристика е:
        
        <p>Допускателна – не надценява разстоянието,
        <p>Консистентна – стойностите ѝ не скачат рязко между състоянията.
        </p>
  </section>




  <!-- Къде се използват тези методи -->
  <section id="Къде се използват тези методи" class="content section">
    <h2>Къде се използват тези методи</h2>
    <p>Методите за търсене са основа в много реални приложения:
        Пъзели (като 8-плочките), Роботи, които търсят път в средата, GPS системи за навигация,
        Теореми и логически задачи, Интелигентни домашни асистенти.
        </p>
  </section>

  <!-- Ограничени ресурси-->
  <section id="Ограничени ресурси" class="content section">
    <h4>Ограничени ресурси</h4>
    <p>Понякога няма възможност за пълно обхождане. Затова се използват варианти като:
    <p>    IDA* – итеративно търсене с евристика,
    <p>   RBFS – пази само част от дървото,
    <p>   Real-time A* – работи с ограничен „поглед напред“.
        
        </p>
  </section>

 <!-- Примери-->
 <section id="Примери" class="content section">
    <h4>Примери</h4>
    <p>В шахматни програми се използват алгоритми с дълбочина и алфа-бета отсичане.
    <p>В реални роботи – търсене за оптимален път с избягване на препятствия.
    <p>В навигационни приложения – A* намира най-късия маршрут.
    <p>Домашни уреди – например роботи за почистване използват карта и търсят най-добрия ред за движение.
        </p>
  </section>

 <!--Заключение-->
 <section id="Заключение" class="content section">
    <h2>Заключение</h2>
    <p>Методите за търсене в пространство на състоянията са основна част от ИИ. Те позволяват на системите да вземат решения, да планират и да намират решения дори в сложни ситуации. Изборът на метод зависи от конкретната задача, наличната информация и техническите ограничения.
        </p>
  </section>




  <script>
    const input = document.querySelector('input[type="text"]');
    const sections = document.querySelectorAll('.section');

    input.addEventListener('input', function () {
      const query = this.value.toLowerCase();

      sections.forEach(section => {
        const id = section.id.toLowerCase();
        if (query && id.includes(query)) {
          section.style.display = 'block';
          section.scrollIntoView({ behavior: 'smooth' });
        } else {
          section.style.display = 'none';
        }

        if (!query) {
          section.style.display = 'block';
        }
      });
    });
  </script>

</body>
</html>